pygame.math
pygame module for vector classes

!!!EXPERIMENTAL!!!
Note: This Modul is still in development and the API might change. 
Please report bug and suggestions to pygame-users@seul.org

The pygame math module currently provides Vector classes in two 
and three dimensions, Vector2 and Vector3 respectively.

They support the following numerical operations:
vec+vec, vec-vec, vec*number, number*vec, vec/number, vec//number, 
vec+=vec, vec-=vec, vec*=number, vec/=number, vec//=number. All 
these operations will be performed elementwise.
In addition vec*vec will perform a scalar-product (a.k.a. 
dot-product).
If you want to multiply every element from vector v with every
element from vector w you can use the elementwise method:
v.elementwise() * w


New in Pygame 1.10
 


<SECTION>

enable_swizzling
globally enables swizzling for vectors.
math.enable_swizzling(): return None

Enables swizzling for all vectors until disable_swizzling() is 
called. By default swizzling is disabled.
<END>



disable_swizzling
globally disables swizzling for vectors.
math.disable_swizzling(): return None

Disables swizzling for all vectors until enable_swizzling() is 
called. By default swizzling is disabled.
<END>



Vector2
a 2-Dimensional Vector
pygame.math.Vector2(): return Vector2
pygame.math.Vector2(Vector2): return Vector2
pygame.math.Vector2(x, y): return Vector2
pygame.math.Vector2((x, y)): return Vector2

Some general information about the Vector2 class.

<SECTION>


dot
calculates the dot- or scalar-product with the other vector
Vector2.dot(Vector2): return float

<END>



cross
calculates the cross- or vector-product
Vector2.cross(Vector2): return float

calculates the third component of the cross-product.
<END>



length
returns the euclidic length of the vector.
Vector2.length(): return float

calculates the euclidic length of the vector which follows from 
the Pythagorean theorem: 
vec.length() == math.sqrt(vec.x**2 + vec.y**2)
<END>



length_squared
returns the squared euclidic length of the vector.
Vector2.length_squared(): return float

calculates the euclidic length of the vector which follows from 
the Pythagorean theorem: 
vec.length_squared() == vec.x**2 + vec.y**2
This is faster than vec.length() because it avoids the square 
root.
<END>



normalize
returns a vector with the same direction but length 1.
Vector2.normalize(): return Vector2

Returns a new vector that has length == 1 and the same direction 
as self.
<END>



normalize_ip
normalizes the vector in place so that its length is 1.
Vector2.normalize_ip(): return None

Normalizes the vector so that it has length == 1. The direction 
of the vector is not changed.
<END>



is_normalized
tests if the vector is normalized i.e. has length == 1.
Vector2.is_normalized(): return Bool

Returns True if the vector has length == 1. Otherwise it returns 
False.
<END>



scale_to_length
scales the vector to a given length.
Vector2.scale_to_length(float): return None

Scales the vector so that it has the given length. The direction 
of the vector is not changed. You can also scale to length 0. 
If the vector is the zero vector (i.e. has length 0 thus no 
direction) an ZeroDivisionError is raised.
<END>



reflect
returns a vector reflected of a given normal.
Vector2.reflect(Vector2): return Vector2

Returns a new vector that points in the direction as if self 
would bounce of a surface characterized by the given surface 
normal. The length of the new vector is the same as self's.
<END>



reflect_ip
reflect the vector of a given normal in place.
Vector2.reflect_ip(Vector2): return None

Changes the direction of self as if it would have been reflected
of a surface with the given surface normal.
<END>



distance_to
calculates the euclidic distance to a given vector.
Vector2.distance_to(Vector2): return float

<END>



distance_squared_to
calculates the squared euclidic distance to a given vector.
Vector2.distance_squared_to(Vector2): return float

<END>



lerp
returns a linear interpolation to the given vector.
Vector2.lerp(Vector2, float): return Vector2

Returns a Vector which is a linear interpolation between self and
the given Vector. The second parameter determines how far between 
self an other the result is going to be. It must be a value between
0 and 1 where 0 means self an 1 means other will be returned.

<END>



slerp
returns a spherical interpolation to the given vector.
Vector2.slerp(Vector2, float): return Vector2

Calculates the spherical interpolation from self to the given Vector. 
The second argument - often called t - must be in the range [-1, 1]. 
It parametrizes where - in between the two vectors - the result should 
be. If a negative value is given the interpolation will not take the 
complement of the shortest path.

<END>


elementwise
The next operation will be performed elementwize.
Vector2.elementwise(): return VectorElementwizeProxy

Applies the following operation to each element of the vector.
<END>


rotate
rotates a vector by a given angle in degrees.
Vector2.rotate(float): return Vector2

Returns a vector which has the same length as self but is
rotated counterclockwise by the given angle in degrees.
<END>


rotate_ip
rotates the vector by a given angle in degrees in place.
Vector2.rotate_ip(float): return None

Rotates the vector counterclockwise by the given angle in 
degrees. The length of the vector is not changed.
<END>


angle_to
calculates the angle to a given vector in degrees.
Vector2.angle_to(Vector2): return float

Returns the angle between self and the given vector.
<END>


as_polar
returns a tuple with radial distance and azimuthal angle.
Vector2.as_polar(): return (r, phi)

Returns a tuple (r, phi) where r is the radial distance, 
and phi is the azimuthal angle.
<END>



from_polar
Sets x and y from a polar coordinates tuple.
Vector2.from_polar((r, phi)): return None

Sets x and y from a tuple (r, phi) where r is the radial distance,
and phi is the azimuthal angle.
<END>
<END>




Vector3
a 3-Dimensional Vector
pygame.math.Vector3(): return Vector3
pygame.math.Vector3(Vector3): return Vector3
pygame.math.Vector3(x, y, z): return Vector3
pygame.math.Vector3((x, y, z)): return Vector3

Some general information about the Vector3 class.

<SECTION>


dot
calculates the dot- or scalar-product with the other vector
Vector3.dot(Vector3): return float

<END>



cross
calculates the cross- or vector-product
Vector3.cross(Vector3): return float

calculates the cross-product.
<END>



length
returns the euclidic length of the vector.
Vector3.length(): return float

calculates the euclidic length of the vector which follows from 
the Pythagorean theorem: 
vec.length() == math.sqrt(vec.x**2 + vec.y**2 + vec.z**2)
<END>



length_squared
returns the squared euclidic length of the vector.
Vector3.length_squared(): return float

calculates the euclidic length of the vector which follows from 
the Pythagorean theorem: 
vec.length_squared() == vec.x**2 + vec.y**2 + vec.z**2
This is faster than vec.length() because it avoids the square 
root.
<END>



normalize
returns a vector with the same direction but length 1.
Vector3.normalize(): return Vector3

Returns a new vector that has length == 1 and the same direction 
as self.
<END>



normalize_ip
normalizes the vector in place so that its length is 1.
Vector3.normalize_ip(): return None

Normalizes the vector so that it has length == 1. The direction 
of the vector is not changed.
<END>



is_normalized
tests if the vector is normalized i.e. has length == 1.
Vector3.is_normalized(): return Bool

Returns True if the vector has length == 1. Otherwise it returns 
False.
<END>



scale_to_length
scales the vector to a given length.
Vector3.scale_to_length(float): return None

Scales the vector so that it has the given length. The direction 
of the vector is not changed. You can also scale to length 0. 
If the vector is the zero vector (i.e. has length 0 thus no 
direction) an ZeroDivisionError is raised.
<END>



reflect
returns a vector reflected of a given normal.
Vector3.reflect(Vector3): return Vector3

Returns a new vector that points in the direction as if self 
would bounce of a surface characterized by the given surface 
normal. The length of the new vector is the same as self's.
<END>



reflect_ip
reflect the vector of a given normal in place.
Vector3.reflect_ip(Vector3): return None

Changes the direction of self as if it would have been reflected
of a surface with the given surface normal.
<END>



distance_to
calculates the euclidic distance to a given vector.
Vector3.distance_to(Vector3): return float

<END>



distance_squared_to
calculates the squared euclidic distance to a given vector.
Vector3.distance_squared_to(Vector3): return float

<END>



lerp
returns a linear interpolation to the given vector.
Vector3.lerp(Vector3, float): return Vector3

Returns a Vector which is a linear interpolation between self and
the given Vector. The second parameter determines how far between 
self an other the result is going to be. It must be a value between
0 and 1 where 0 means self an 1 means other will be returned.

<END>



slerp
returns a spherical interpolation to the given vector.
Vector3.slerp(Vector3, float): return Vector3

Calculates the spherical interpolation from self to the given Vector. 
The second argument - often called t - must be in the range [-1, 1]. 
It parametrizes where - in between the two vectors - the result should 
be. If a negative value is given the interpolation will not take the 
complement of the shortest path.

<END>


elementwise
The next operation will be performed elementwize.
Vector3.elementwise(): return VectorElementwizeProxy

Applies the following operation to each element of the vector.
<END>


rotate
rotates a vector by a given angle in degrees.
Vector3.rotate(Vector3, float): return Vector3

Returns a vector which has the same length as self but is
rotated counterclockwise by the given angle in degrees
around the given axis.
<END>


rotate_ip
rotates the vector by a given angle in degrees in place.
Vector3.rotate_ip(Vector3, float): return None

Rotates the vector counterclockwise around the given
axis by the given angle in degrees. The length of the 
vector is not changed.
<END>


rotate_x
rotates a vector around the x-axis by the angle in degrees.
Vector3.rotate_x(float): return Vector3

Returns a vector which has the same length as self but is
rotated counterclockwise around the x-axis by the given 
angle in degrees.
<END>


rotate_x_ip
rotates the vector around the x-axis by the angle in degrees in place.
Vector3.rotate_x_ip(float): return None

Rotates the vector counterclockwise around the x-axis by 
the given angle in degrees. The length of the vector is 
not changed.
<END>

rotate_y
rotates a vector around the y-axis by the angle in degrees.
Vector3.rotate_y(float): return Vector3

Returns a vector which has the same length as self but is
rotated counterclockwise around the y-axis by the given 
angle in degrees.
<END>


rotate_y_ip
rotates the vector around the y-axis by the angle in degrees in place.
Vector3.rotate_y_ip(float): return None

Rotates the vector counterclockwise around the y-axis by 
the given angle in degrees. The length of the vector is 
not changed.
<END>

rotate_z
rotates a vector around the z-axis by the angle in degrees.
Vector3.rotate_z(float): return Vector3

Returns a vector which has the same length as self but is
rotated counterclockwise around the z-axis by the given 
angle in degrees.
<END>


rotate_z_ip
rotates the vector around the z-axis by the angle in degrees in place.
Vector3.rotate_z_ip(float): return None

Rotates the vector counterclockwise around the z-axis by 
the given angle in degrees. The length of the vector is 
not changed.
<END>


angle_to
calculates the angle to a given vector in degrees.
Vector3.angle_to(Vector3): return float

Returns the angle between self and the given vector.
<END>


as_spherical
returns a tuple with radial distance, inclination and azimuthal angle.
Vector3.as_spherical(): return (r, theta, phi)

Returns a tuple (r, theta, phi) where r is the radial distance, 
theta is the inclination angle and phi is the azimuthal angle.
<END>



from_spherical
Sets x, y and z from a spherical coordinates 3-tuple.
Vector3.from_spherical((r, theta, phi)): return None

Sets x, y and z from a tuple (r, theta, phi) where r is the 
radial distance, theta is the inclination angle and phi is the 
azimuthal angle.
<END>



<END>
<END>



